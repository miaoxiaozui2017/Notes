# Scopes作用域
使用前需要声明命名实体，声明发生的位置会影响可见性。  
- 在任何块之外声明的实体具有全局作用域。（全局变量）  
- 在块内声明的实体（如函数或选择性语句）具有块作用域，只在声明它的特定块内可见，而不在其外部可见。（局部变量）
```c++
int foo;    // 全局变量
int some_function()
{
    int bar;    // 局部变量
    bar = 0;
}

int other_function()
{
    foo = 1;    // ok：foo是一个全局变量
    bar = 2;    // wrong：bar在这个函数中不可见
}
```
在同一个作用域下，该名称只能用于表示一个实体。
```c++
int some_function()
{
    int x;
    x = 0;
    double x;   // wrong:这个范围中已经使用了名称
    x = 0.0;
}
```
局部变量的可见性扩展到整个块内，包括内部块。  
但内部块可以重用外部作用域中存在的名称来引用不同的实体，即内部块内的实体有效，对外隐藏，跳出块之后继续引用原始实体。  
在引入块的声明中声明的变量，例如在循环和条件中声明的函数参数和变量，是它们引入的块的本地变量。

# Namespaces名称空间
问题：库可能声明许多函数、类型和变量，可能会带来名称冲突。  
解决方案：使用名称空间将具有全局作用域的命名实体分组到更窄的作用域中，从而为它们提供名称空间作用域。  
namespace identifier  
{  
$\quad\quad$named_entities  
}  
identifier：任何有效标识符  
named_entities：包含在名称空间中的变量、类型和函数集。
```c++
namespace myNamespace
{
    int a,b;
}
```
当在外部访问名称空间内的变量时，需要用::限定。
```c++
myNamespace::a
myNamespace::b
```
名称空间可以拆分  
```c++
namespace foo { int a; }
namespace bar { int b; }
namespace foo { int c; }
```  
名称空间可以扩展到不同的翻译单元（例如，跨不同的源代码文件）

# using
将名称引入当前声明性区域（例如块），从而避免限定名称的需要。  
也可以直接引入整个名称空间。  
可以先使用一个名称空间的对象，然后通过将代码分成不同的块来使用另一个名称空间的对象。

# Namespace aliasing
现有名称空间可以用新名称别名，语法如下：  
namespace new_name = current_name;  

# The std namespace
标准c++库的所有实体都在std名称空间中声明。  
```c++
using namespace std;  
{
    // ...
    cout << "Hello world!";
} 
// 等价于
std::cout << "Hello world!";
```
两种写法不影响程序的行为或效率，但对于混合库的项目，更倾向于使用显式限定。

# Storage classes存储类
静态存储：具有全局作用域或名称空间作用域的变量的存储将在整个程序期间分配。  
自动存储：本地变量（在块中声明的变量）的存储仅在块内可用，函数内同理。  
静态存储变量和动态存储变量的重要区别：  
- 未显式初始化的静态存储变量（如全局变量）将自动初始化为0。
- 未显式初始化的具有自动存储的变量（如本地变量）未初始化，因此具有未确定值。
（但大多数现代编译器会对这种情况做处理，如给y也自动初始化成0）
