# Implicit conversion隐式转换
当将值复制到兼容类型时，自动执行隐式转换。
```c++
short a = 2000;
int b;
b = a;  // 这里a的类型从short转换到int，不需要任何显式操作符（标准转换）
```
标准转换会影响基本数据类型，并允许数值类型（short到int、int到float、double到int）从或到布尔类型转换，和类似的指针转换。  
- 提升：从某种较小的整数类型转换为整形，或者从float转换为double，并保证在目标类型中产生完全相同的值。（算术类型之间的一些转换不总能够准确表示相同的值，如负整数值到转换为无符号类型）
- 从或到布尔类型的转换认为false等价于0（数值类型）和null指针（指针类型）；true等价于所有其他值，并被转换为1.
- 浮点类型到整数类型，值将被截断（去掉小数部分）。如果超出当前类型可表示值的范围，转换将导致未定义的行为
- 如果转换是在同类型的数值类型（整数到整数或浮点到浮点）之间，转换有效，但该值是特定于实现的（且可能不可移植）
- 有些转换可能损失精度，编译器可能会警告，通过显式转换可以避免此警告。
- 对于非基本类型，数组和函数隐式地转换为指针
- 指针允许的转换：空指针可以转换为任何类型的指针，指向任何类型的指针都可以转化为空指针，指针向上转换（指向派生类的指针可以转换为具有可访问且明确基类的指针，而无需修改其const或volatile限定）

# Implicit conversions with classes类间的隐式转换
类间的隐式转换可以通过三个成员函数来控制：  
- `单参数构造函数`：允许从特定类型到初始化对象的隐式转换
- `赋值运算符`：允许对赋值从特定类型进行隐式转换
- `类型转换操作符`：允许隐式转换到特定类型

例子见../../codes/Other language features/implicit conversion classes.cpp

# Keyword explicit关键字显式
问题：对于类的隐式转换可能会有些问题（ 如果类间可以隐式转换，当出现两个不同类对象时，函数可能会调用你预想之外的那个对象。）  
解决方案：可以通过显式关键字标记受影响的构造函数

# Type casting类型转换
泛型类型转换主要有两种语法：泛型类型转换函数和类c类型转换  
```c++
double x = 10.3;
int y;
y = int(x);     // 类型转换函数
y = (int)x;     // 类c类型转换
```
但是以上方法直接用在类和指向类的指针上时，可能导致代码（语法正确）运行时错误  
为了在类间控制类型转换，四个特定的转换操作符：  
```c++
dynamic_cast <new_type>(expression)
reinterpret_cast <new_type>(expression)
static_cast <new_type>(expression)
const_cast <new_type>(expression)
```
与以上表达式等价的传统类型转换：  
```c++
(new_type)expression
new_type (expression)
```

# dynamic_cast
`dynamic_cast`只能与类的指针和引用一起使用（或者与void*一起使用）。  
目的是确保类型转换的结果指向一个目标指针类型的有效完整对象。  
- 向上转换，即从指向派生类指针转换到指向基类指针，类似隐式转换；
- 向下转换多态类，即从指向基类指针转换到指向派生类，仅当所指向的对象是目标类型的有效完整对象

>Note  
>$\quad\quad$兼容性：这种类型的dynamic_cast需要运行时类型信息（RTTI）来跟踪动态类型。一些编译器支持这个特性作为默认禁用的选项。需要使用dynamic_cast启用它来进行运行时类型检查，以便正确处理这些类型。

- 如果使用dynamic_cast转换为引用类型，并且转换不可能，则会抛出bad_cast类型异常。
- dynamic_cast还可以执行指针上允许的其他隐式类型转换：在指针类型之间转换null指针（甚至在不相关的类之间），以及将任何类型的任何指针转换为void*指针。

# static_cast
`static_cast`可以在指向相关类的指针之间进行转换（向上转换or向下转换）。在运行时不执行检查，由程序员来确保转换是安全的，因此不会产生类型安全检查的开销。
```c++
class Base{};
class Derived:public Base{};
Base * a = new Base;
Derived * b = static_cast<Derived*>(a);
// 有效的代码，尽管b指向类的不完整对象，且如果解引用可能会导致运行时错误。
```
- static_cast能够使用指针来执行，这些指针不仅指向隐式允许的转换，而且指向它们相反的转换。
- 还能够执行隐式允许的所有转换（不仅是那些具有指向类的指针的转换），而且还能够执行与之相反的转换。
- 从void\*转换为任何指针类型。（确保如果void\*值是从相同的指针类型转换得到的，那么得到的指针值是相同的）
- 将整数、浮点数和枚举类型转换为enum类型。
- 显式调用单参数构造函数或转换操作符
- 转换为rvalue引用
- 将枚举类值转换为整数或浮点值
- 将任何类型转换为void，计算并丢弃该值

# reinterpret_cast
`reinterpret_cast`将任何指针类型转换为任何其它指针类型，即使是不相关的类。  
- 结果是从一个指针到另一个指针的值的简单二进制拷贝。  
- 所有指针转换都是允许的：既不检查指向的内容，也不检查指针类型本身。  
- 可以转换到或从整数类型为指针，整数值表示指针的格式是特定于平台的。唯一能确保的是转换为整数值足够大，能完全包含指针，并确保再转换到指针时是有效的。  
- reinterpret_cast可以转换基于重新解释类型的二进制表示的低级操作，但这种转换大多数情况会导致特定于系统的代码，因此不可移植。
```c++
// example
class A{/*...*/}
class B{/*...*/}
A * a = new A;
B * b = reinterpret_cast<B*>(a);
```

# const_cast
`const_cast`的类型转换操作指针所指向的对象的一致性，指针可以是要设置的或是要删除的。  
例子：  
- 为了传递一个const指针给一个函数，该函数需要一个非const参数；  

>Note:  
>$\quad\quad$删除指向对象而实际写入该对象的一致性会导致未定义行为。

# typeid
`typeid`允许检查表达式的类型：  
```c++
typeid(expression)
```
- 返回值为type_info类型的常量对象（在标准头\<typeinfo\>中定义）的引用
- 返回值可以进行==和！=的比较，也可以通过使用name()成员函数来获得表示类型或类名的以null结尾的字符序列
- 当typeid应用于类时，使用RTTI来跟踪动态对象的类型。
- 当typeid应用于类型为多态类的表达式时，结果是派生最完整对象的类型。
>Note:
>$\quad\quad$由type_info成员名返回的字符串取决于编译器和库的特定实现。它不一定是一个具有典型类型名称的简单字符串。（MS的V8和GUN的GCC编译的结果不一样）